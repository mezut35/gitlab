import asyncio
import re
import aiohttp
import logging
from telethon import TelegramClient, events

# -----------------------------------------------------------------------------
# Loglama AyarlarÄ±
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("telegram_bot.log"),
        logging.StreamHandler()
    ]
)

# -----------------------------------------------------------------------------
# Telegram API Bilgileri (Verilen Bilgiler)
api_id = 20642723
api_hash = "6c5e7c19f3a701201707ee28da0a40f6"
session_name = "amznbbt"
phone_number = "306940656110"  # Ãœlke kodu ile tam numara

# -----------------------------------------------------------------------------
# Kaynak ve Hedef Kanallar
SOURCE_CHANNELS = ["@couponsundrabatte2" , "@Beauty_Schoenheit" ]  # MesajlarÄ± dinleyeceÄŸimiz kanal(lar)
TARGET_CHANNEL = "@bbtdeals"              # DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ mesajlarÄ±n gÃ¶nderileceÄŸi kanal

# -----------------------------------------------------------------------------
# Amazon Affiliate AyarlarÄ±
AFFILIATE_TAG = "bbtdeals0d-21"

# -----------------------------------------------------------------------------
# Amazon Link Ä°ÅŸleme SÄ±nÄ±fÄ±
class AmazonLinkProcessor:
    """
    Amazon linklerini aÃ§Ä±p yÃ¶nlenen final URL'den Ã¼rÃ¼n ID'sini alÄ±r,
    ve bu ID Ã¼zerinden yalnÄ±zca affiliate tag parametresini iÃ§eren sade bir affiliate link oluÅŸturur.

    OluÅŸturulan link formatÄ±:
    https://www.amazon.de/dp/<PRODUCT_ID>?tag=AFFILIATE_TAG
    """
    def __init__(self, affiliate_tag, session):
        self.affiliate_tag = affiliate_tag
        self.session = session

    async def get_final_url(self, url: str) -> str:
        """KÄ±saltÄ±lmÄ±ÅŸ veya yÃ¶nlendiren Amazon linkini aÃ§ar ve final URL'yi dÃ¶ndÃ¼rÃ¼r."""
        try:
            async with self.session.get(url, timeout=10, allow_redirects=True) as response:
                final_url = str(response.url)
                logging.info(f"ğŸ”„ Ã‡Ã¶zÃ¼mlenen Link: {url} â {final_url}")
                return final_url
        except Exception as e:
            logging.error(f"ğŸ”´ get_final_url hata: {e} - URL: {url}")
            return None

    def extract_product_id(self, url: str) -> str:
        """
        Final URL iÃ§erisinden Amazon Ã¼rÃ¼n ID'sini (ASIN) Ã§Ä±kartÄ±r.
        Standart /dp/ veya /gp/product/ desenlerinin yanÄ± sÄ±ra,
        bazÄ± durumlarda URL iÃ§inde 'asin=' parametresi de bulunabilir.
        """
        patterns = [
            r'(?:/dp/|/gp/product/)([A-Z0-9]{10})',
            r'asin=([A-Z0-9]{10})'
        ]
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                product_id = match.group(1)
                logging.info(f"ÃœrÃ¼n ID'si bulundu: {product_id}")
                return product_id
        logging.error(f"ÃœrÃ¼n ID'si bulunamadÄ±: {url}")
        return None

    def generate_affiliate_url(self, product_id: str) -> str:
        """Affiliate link oluÅŸturur."""
        return f"https://www.amazon.de/dp/{product_id}?tag={self.affiliate_tag}"

    async def process_amazon_link(self, link: str) -> str:
        """Amazon linkini alÄ±r, yÃ¶nlendirmeleri takip edip affiliate linke dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r."""
        logging.info(f"ğŸ”„ Amazon link iÅŸleniyor: {link}")
        final_url = await self.get_final_url(link)
        if not final_url:
            logging.error("ğŸ”´ Amazon linki Ã§Ã¶zÃ¼mlenemedi.")
            return None

        product_id = self.extract_product_id(final_url)
        if not product_id:
            logging.error(f"ğŸ”´ ÃœrÃ¼n ID'si bulunamadÄ±. Final URL: {final_url}")
            return None

        affiliate_url = self.generate_affiliate_url(product_id)
        logging.info(f"âœ… Affiliate Link oluÅŸturuldu: {affiliate_url}")
        return affiliate_url

# -----------------------------------------------------------------------------
# Telegram GiriÅŸ ve DoÄŸrulama Fonksiyonu
async def login_to_telegram():
    client = TelegramClient(session_name, api_id, api_hash)
    await client.connect()

    if not await client.is_user_authorized():
        logging.info("ğŸ”µ DoÄŸrulama kodu gÃ¶nderiliyor...")
        await client.send_code_request(phone_number)
        code = input("ğŸ“Œ Telegram doÄŸrulama kodunu girin: ")
        try:
            await client.sign_in(phone_number, code)
            logging.info("âœ… BaÅŸarÄ±yla giriÅŸ yapÄ±ldÄ±!")
        except Exception as e:
            logging.error(f"ğŸ”´ GiriÅŸ hatasÄ±: {e}")
    else:
        logging.info("âœ… Oturum zaten yetkilendirilmiÅŸ.")

    return client

# -----------------------------------------------------------------------------
# MesajÄ± Ä°ÅŸleyip Hedef Kanala GÃ¶nderen Fonksiyon
async def forward_message(message, client, processor):
    try:
        # Raw text veya normal text alÄ±nÄ±r
        text = getattr(message, "raw_text", None) or (message.text or message.caption or "")
        if not text:
            logging.warning("âš  Gelen mesajda okunabilir metin bulunamadÄ±.")
        else:
            logging.info(f"ğŸ“¥ Mesaj yakalandÄ± (kaynak kanal): {message.chat_id if message.chat_id else 'Bilinmiyor'}")
            logging.info("ğŸ“„ Orijinal mesaj iÃ§eriÄŸi:\n" + text)

        # Amazon linklerini tespit eden regex: amazon.de, amzn.to, amzn.eu
        pattern = r"(https?://(?:www\.)?(?:amazon\.de|amzn\.to|amzn\.eu)[^\s]+)"
        found_links = re.findall(pattern, text)

        logging.info(f"ğŸ” Mesajda bulunan link adedi: {len(found_links)}")
        if found_links:
            logging.info("ğŸ” Tespit edilen linkler: " + ", ".join(found_links))
            conversion_failed = False
            for link in found_links:
                affiliate_link = await processor.process_amazon_link(link)
                if affiliate_link:
                    text = text.replace(link, affiliate_link)
                    logging.info(f"âœï¸ Link dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼: {link} -> {affiliate_link}")
                else:
                    logging.error(f"ğŸš¨ Affiliate link oluÅŸturulamadÄ±: {link}")
                    conversion_failed = True
            if conversion_failed:
                logging.error("ğŸš¨ BazÄ± linkler dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lemediÄŸi iÃ§in mesaj gÃ¶nderilmiyor.")
                return  # DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lemeyen link varsa mesaj gÃ¶nderilmiyor.
        else:
            logging.info("ğŸ” Mesajda Amazon linki bulunamadÄ±.")

        logging.info("ğŸ’¬ DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ mesaj iÃ§eriÄŸi:\n" + text)
        try:
            await client.send_message(TARGET_CHANNEL, text)
            logging.info(f"âœ… DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ mesaj baÅŸarÄ±yla gÃ¶nderildi: Hedef Kanal: {TARGET_CHANNEL}")
        except Exception as send_error:
            logging.error(f"ğŸš¨ Mesaj gÃ¶nderme hatasÄ±: {send_error}")
    except Exception as e:
        logging.error(f"ğŸ”´ Mesaj iÅŸleme hatasÄ±: {e}")

# -----------------------------------------------------------------------------
# Botun MesajlarÄ± Dinlemesini SaÄŸlayan Fonksiyon
async def start_bot():
    client = await login_to_telegram()

    async with aiohttp.ClientSession() as aiohttp_session:
        processor = AmazonLinkProcessor(AFFILIATE_TAG, aiohttp_session)

        @client.on(events.NewMessage(chats=SOURCE_CHANNELS))
        async def channel_message_handler(event):
            logging.info("ğŸ“¨ Yeni mesaj alÄ±ndÄ±.")
            if event.message:
                try:
                    source = getattr(event.message.peer_id, "channel_id", "Bilinmiyor")
                    logging.info(f"ğŸ“¡ MesajÄ±n geldiÄŸi kanal ID: {source}")
                except Exception as e:
                    logging.warning(f"âš  Kaynak kanal bilgisi alÄ±namadÄ±: {e}")
                await forward_message(event.message, client, processor)
            else:
                logging.warning("âš  Olayda mesaj verisi bulunamadÄ±.")

        logging.info("ğŸš€ Bot Ã§alÄ±ÅŸÄ±yor, mesajlar dinleniyor...")
        await client.run_until_disconnected()

# -----------------------------------------------------------------------------
# Botu BaÅŸlat
if __name__ == '__main__':
    try:
        asyncio.run(start_bot())
    except KeyboardInterrupt:
        logging.info("ğŸ›‘ Program kapatÄ±lÄ±yor...")

