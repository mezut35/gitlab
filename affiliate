import asyncio
import re
import aiohttp
import logging
from telethon import TelegramClient, events
from telethon.errors import RPCError, SessionPasswordNeededError, FloodWaitError

# ğŸ“Œ Loglama AyarlarÄ±
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("telegram_bot.log"),
        logging.StreamHandler()
    ]
)

# ğŸ“Œ Telegram API Bilgileri
api_id = 24974416
api_hash = "1c201b57b44b2fd17ef0d9de833bea57"
session_name = "aliveli"

# ğŸ“Œ Kaynak ve Hedef Kanallar
SOURCE_CHANNEL = "@Elektro_Gaming"   # MesajlarÄ± yakalayacaÄŸÄ±mÄ±z kanal (gÃ¼ncellendi)
TARGET_CHANNEL = "@bbttestamazon"      # Affiliate linkin gÃ¶nderileceÄŸi kanal

# ğŸ“Œ Amazon Affiliate AyarlarÄ±
AFFILIATE_TAG = "bbtdeals0d-21"

# ğŸ“Œ Session Headers
session_headers = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36"
}

# ğŸ“Œ Amazon Link Ä°ÅŸleme SÄ±nÄ±fÄ±
class AmazonLinkProcessor:
    """Amazon kÄ±sa linklerini Ã§Ã¶zÃ¼mler ve affiliate linklere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r."""
    
    def __init__(self, affiliate_tag, session):
        self.affiliate_tag = affiliate_tag
        self.session = session

    async def get_final_url(self, short_url: str) -> str:
        """KÄ±sa Amazon URL'yi Ã§Ã¶zÃ¼mler ve gerÃ§ek yÃ¶nlendirilmiÅŸ linki dÃ¶ndÃ¼rÃ¼r."""
        try:
            async with self.session.get(short_url, timeout=10, allow_redirects=True) as response:
                final_url = str(response.url)
                logging.info(f"ğŸ”„ Ã‡Ã¶zÃ¼mlenen Link: {short_url} â {final_url}")
                return final_url
        except Exception as e:
            logging.error(f"ğŸ”´ get_final_url hata: {e}")
            return None

    def extract_product_id(self, url: str) -> str:
        """Amazon URL iÃ§indeki Ã¼rÃ¼n ID'sini Ã§Ä±kartÄ±r."""
        match = re.search(r'(?:/dp/|/gp/product/)([A-Z0-9]{10})', url)
        if match:
            product_id = match.group(1)
            logging.info(f"ÃœrÃ¼n ID'si bulundu: {product_id}")
            return product_id
        logging.error(f"ÃœrÃ¼n ID'si bulunamadÄ±: {url}")
        return None

    def generate_affiliate_url(self, product_id: str) -> str:
        """ÃœrÃ¼n ID'yi affiliate linke Ã§evirir."""
        affiliate_url = (
            f"https://www.amazon.de/dp/{product_id}"
            f"?th=1&linkCode=sl1&tag={self.affiliate_tag}"
            "&language=de_DE&ref_=as_li_ss_tl"
        )
        return affiliate_url

    async def process_amazon_link(self, link: str) -> str:
        """Amazon kÄ±sa linkini affiliate linke dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r."""
        logging.info(f"ğŸ”„ Amazon link iÅŸleniyor: {link}")
        final_url = await self.get_final_url(link)
        if not final_url:
            logging.error("ğŸ”´ Amazon linki Ã§Ã¶zÃ¼mlenemedi.")
            return None

        product_id = self.extract_product_id(final_url)
        if not product_id:
            logging.error(f"ğŸ”´ ÃœrÃ¼n ID'si bulunamadÄ±. Link: {final_url}")
            return None

        affiliate_url = self.generate_affiliate_url(product_id)
        logging.info(f"âœ… Affiliate Link: {affiliate_url}")
        return affiliate_url

# --------------------------------------
# Link iÅŸlemini paralel yÃ¼rÃ¼tecek yardÄ±mcÄ± fonksiyon
async def process_link(link: str, processor, client):
    try:
        affiliate_link = await processor.process_amazon_link(link)
        if affiliate_link:
            try:
                await client.send_message(TARGET_CHANNEL, affiliate_link)
                logging.info(f"âœ… GÃ¶nderildi: {affiliate_link}")
            except Exception as e:
                logging.error(f"ğŸ”´ Kanal mesaj gÃ¶nderme hatasÄ±: {e}")
        else:
            logging.error("ğŸ”´ Affiliate link oluÅŸturulamadÄ±.")
    except Exception as e:
        logging.error(f"ğŸ”´ process_link hatasÄ±: {e}")

# --------------------------------------
# Mesajdaki tÃ¼m linkleri iÅŸleyen fonksiyon
async def process_message(message, processor, client):
    try:
        # BazÄ± mesajlarda linkler caption iÃ§erisinde olabilir
        text = message.text or message.caption or ""
        logging.info(f"ğŸ“© Yeni mesaj alÄ±ndÄ±: {text}")

        # Mesaj iÃ§indeki tÃ¼m linkleri yakalamaya Ã§alÄ±ÅŸÄ±yoruz
        links = re.findall(r'(https?://[^\s]+)', text)
        if not links:
            logging.info("ğŸŸ¡ Mesajda herhangi bir link bulunamadÄ±.")
            return

        # amzn.to linklerini paralel olarak iÅŸleyelim
        tasks = []
        for link in links:
            if "amzn.to" in link:
                tasks.append(process_link(link, processor, client))
        if tasks:
            await asyncio.gather(*tasks)
    except Exception as e:
        logging.error(f"ğŸ”´ process_message sÄ±rasÄ±nda hata: {e}")

# --------------------------------------
# Telethon event listener: Sadece SOURCE_CHANNEL'dan gelen mesajlar
def register_handlers(client, processor):
    @client.on(events.NewMessage(chats=SOURCE_CHANNEL))
    async def channel_message_handler(event):
        try:
            logging.info("Yeni mesaj yakalandÄ±.")
            logging.info(f"Mesaj: {event.message}")
            await process_message(event.message, processor, client)
        except Exception as e:
            logging.error(f"ğŸ”´ channel_message_handler hatasÄ±: {e}")

# --------------------------------------
# Botu sÃ¼rekli Ã§alÄ±ÅŸÄ±r halde tutan ana fonksiyon
async def start_bot():
    retry_delay = 5  # Ä°lk yeniden baÄŸlanma sÃ¼resi 5 saniye

    # Telethon client'Ä± burada oluÅŸturuyoruz
    client = TelegramClient(session_name, api_id, api_hash)

    # aiohttp session'Ä± asenkron blok iÃ§erisinde oluÅŸturuyoruz
    async with aiohttp.ClientSession(headers=session_headers) as aiohttp_session:
        processor = AmazonLinkProcessor(AFFILIATE_TAG, aiohttp_session)
        register_handlers(client, processor)

        while True:
            try:
                logging.info("ğŸš€ Aliveli userbot baÅŸlatÄ±lÄ±yor...")
                await client.connect()

                if not await client.is_user_authorized():
                    logging.warning("âš  BaÄŸlantÄ± yetkisiz! LÃ¼tfen telefon numarasÄ± ile giriÅŸ yapÄ±n.")
                    await client.send_code_request("+905325674607")
                    code = input("Telegram Kodunu Girin: ")
                    await client.sign_in("+905325674607", code)

                logging.info("âœ… BaÄŸlantÄ± baÅŸarÄ±lÄ±, bot Ã§alÄ±ÅŸÄ±yor...")
                await client.run_until_disconnected()
            except FloodWaitError as e:
                wait_time = e.seconds
                logging.warning(f"ğŸŸ¡ FloodWaitError: {wait_time} saniye bekleniyor...")
                await asyncio.sleep(wait_time)
            except (RPCError, SessionPasswordNeededError, OSError) as e:
                logging.warning(f"ğŸ”„ BaÄŸlantÄ± hatasÄ±: {e}. {retry_delay} saniye sonra yeniden baÄŸlanÄ±lÄ±yor...")
                await asyncio.sleep(retry_delay)
                retry_delay = min(retry_delay * 2, 60)  # Maksimum 60 saniye bekleyin
            except Exception as e:
                logging.error(f"ğŸ”´ Beklenmedik hata: {e}")
                await asyncio.sleep(retry_delay)

# --------------------------------------
# Program baÅŸlangÄ±cÄ±
if __name__ == '__main__':
    try:
        asyncio.run(start_bot())
    except KeyboardInterrupt:
        logging.info("Program kapatÄ±lÄ±yor...")
