import asyncio
import re
import aiohttp
import logging
from telethon import TelegramClient, events
from telethon.errors import RPCError, SessionPasswordNeededError, FloodWaitError

# **ğŸ“Œ Loglama AyarlarÄ±**
logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("telegram_bot.log"),
        logging.StreamHandler()
    ]
)

# **ğŸ“Œ Telegram API Bilgileri**
api_id = 24974416
api_hash = "1c201b57b44b2fd17ef0d9de833bea57"
session_name = "aliveli"

# **ğŸ“Œ Kaynak ve Hedef Kanallar**
SOURCE_CHANNEL = "@Beauty_Schoenheit"
TARGET_CHANNEL = "@bbttestamazon"

# **ğŸ“Œ Amazon Affiliate AyarlarÄ±**
AFFILIATE_TAG = "bbtdeals0d-21"

# **ğŸ“Œ Amazon Link Ä°ÅŸleme SÄ±nÄ±fÄ±**
class AmazonLinkProcessor:
    """Amazon kÄ±sa linklerini Ã§Ã¶zÃ¼mler ve affiliate linklere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r."""

    def __init__(self, affiliate_tag):
        self.affiliate_tag = affiliate_tag

    async def get_final_url(self, short_url: str) -> str:
        """KÄ±sa Amazon URL'yi Ã§Ã¶zÃ¼mler ve gerÃ§ek yÃ¶nlendirilmiÅŸ linki dÃ¶ndÃ¼rÃ¼r."""
        headers = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36"
        }
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(short_url, headers=headers, timeout=10, allow_redirects=True) as response:
                    final_url = str(response.url)
                    logging.info(f"ğŸ”„ Ã‡Ã¶zÃ¼mlenen Link: {short_url} â {final_url}")
                    return final_url
        except Exception as e:
            logging.error(f"ğŸ”´ get_final_url hata: {e}")
            return None

    def extract_product_id(self, url: str) -> str:
        """Amazon URL iÃ§indeki Ã¼rÃ¼n ID'sini Ã§Ä±kartÄ±r."""
        match = re.search(r'(?:/dp/|/gp/product/)([A-Z0-9]{10})', url)
        return match.group(1) if match else None

    def generate_affiliate_url(self, product_id: str) -> str:
        """ÃœrÃ¼n ID'yi affiliate linke Ã§evirir."""
        return f"https://www.amazon.de/dp/{product_id}?th=1&linkCode=sl1&tag={self.affiliate_tag}&language=de_DE&ref_=as_li_ss_tl"

    async def process_amazon_link(self, link: str) -> str:
        """Amazon kÄ±sa linkini affiliate linke dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r."""
        logging.info(f"ğŸ”„ Amazon link iÅŸleniyor: {link}")

        final_url = await self.get_final_url(link)
        if not final_url:
            logging.error("ğŸ”´ Amazon linki Ã§Ã¶zÃ¼mlenemedi.")
            return None

        product_id = self.extract_product_id(final_url)
        if not product_id:
            logging.error(f"ğŸ”´ ÃœrÃ¼n ID'si bulunamadÄ±. Link: {final_url}")
            return None

        affiliate_url = self.generate_affiliate_url(product_id)
        logging.info(f"âœ… Affiliate Link: {affiliate_url}")
        return affiliate_url

# **ğŸ“Œ Telethon Client BaÅŸlat**
client = TelegramClient(session_name, api_id, api_hash)
processor = AmazonLinkProcessor(AFFILIATE_TAG)

async def process_message(message):
    """Mesajdaki linkleri bulur ve iÅŸler."""
    text = message.message or ""
    logging.info(f"ğŸ“© Yeni mesaj alÄ±ndÄ±: {text}")

    # Mesaj iÃ§indeki tÃ¼m linkleri bul
    links = re.findall(r'(https?://[^\s]+)', text)
    if not links:
        logging.info("ğŸŸ¡ Mesajda herhangi bir link bulunamadÄ±.")
        return

    for link in links:
        if "amzn.to" in link:
            affiliate_link = await processor.process_amazon_link(link)
            if affiliate_link:
                try:
                    await client.send_message(TARGET_CHANNEL, affiliate_link)
                    logging.info(f"âœ… GÃ¶nderildi: {affiliate_link}")
                except Exception as e:
                    logging.error(f"ğŸ”´ Kanal mesaj gÃ¶nderme hatasÄ±: {e}")
            else:
                logging.error("ğŸ”´ Affiliate link oluÅŸturulamadÄ±.")

@client.on(events.NewMessage(chats=SOURCE_CHANNEL))
async def channel_message_handler(event):
    """Telegram kanalÄ±ndaki yeni mesajlarÄ± iÅŸler."""
    await process_message(event.message)

async def start_bot():
    """Botu sÃ¼rekli Ã§alÄ±ÅŸÄ±r halde tutar ve baÄŸlantÄ± koparsa tekrar baÄŸlanÄ±r."""
    retry_delay = 5  # Ä°lk yeniden baÄŸlanma sÃ¼resi 5 saniye

    while True:
        try:
            logging.info("ğŸš€ Aliveli userbot baÅŸlatÄ±lÄ±yor...")
            await client.connect()

            if not await client.is_user_authorized():
                logging.warning("âš  BaÄŸlantÄ± yetkisiz! LÃ¼tfen telefon numarasÄ± ile giriÅŸ yapÄ±n.")
                await client.send_code_request("+905325674607")
                await client.sign_in("+905325674607", input("Telegram Kodunu Girin: "))

            logging.info("âœ… BaÄŸlantÄ± baÅŸarÄ±lÄ±, bot Ã§alÄ±ÅŸÄ±yor...")
            await client.run_until_disconnected()
        except FloodWaitError as e:
            wait_time = e.seconds
            logging.warning(f"ğŸŸ¡ FloodWaitError: {wait_time} saniye bekleniyor...")
            await asyncio.sleep(wait_time)
        except (RPCError, SessionPasswordNeededError, OSError) as e:
            logging.warning(f"ğŸ”„ BaÄŸlantÄ± hatasÄ±: {e}. {retry_delay} saniye sonra yeniden baÄŸlanÄ±lÄ±yor...")
            await asyncio.sleep(retry_delay)
            retry_delay = min(retry_delay * 2, 60)  # Maksimum 60 saniye bekleyin

if __name__ == '__main__':
    asyncio.run(start_bot())
